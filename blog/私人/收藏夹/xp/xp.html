---
layout: chengjiu
title: XP
nav_url: <a href="/maoqiu">关于</a>
permalink: xp
---
<br><style>#right_anchor2{display:none;}</style>
<script>
// "hr／标题",
// "111／标题／小字／提示",
// ／u／https://xx",
// ／o／dw(dwb='111',dwd='标题')",

//喜好：1还行 2提起兴趣 3想要得到 4计划得到 5必须得到
//邪念：1还行 2心里痒痒 3会有反应 4反应强烈 5难以平复
//1个满分或4+4★ 5+4★★ 双满分★★★
let cj_data={
"普通XP":[

// "/i/cj/xp/123／／／喜好：<br>邪念：",
// "/i/cj/xp/1／／／喜好：<br>邪念：",

"hr／身体",
"/i/cj/xp/55／虎牙／／喜好：★★★★　<br>邪念：★★　　　",
"/i/cj/xp/107／手／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/81／腿／／喜好：★★★★　<br>邪念：★★　　　",
"/i/cj/xp/110／足／／喜好：★★★　　<br>邪念：★★　　　<br>喜欢脚背，不喜欢脚底",
"/i/cj/xp/115／日常光脚／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/108／锁骨／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/120／腰、腹部／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/54／后背／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/1／贫乳 ★／／喜好：★★★★★<br>邪念：★★★　　",
"/i/cj/xp/119／小麦色皮肤／／喜好：★★★　　<br>邪念：★★　　　",

"hr／服装、打扮",
"/i/cj/xp/101／刺青／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/84／穿孔／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/83／Cosplay／／喜好：★★★★　<br>邪念：★★　　　",
"/i/cj/xp/91／睡衣／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/92／浴巾／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/93／长靴／／喜好：★★　　　<br>邪念：★　　　　",
"/i/cj/xp/95／萌え袖／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/105／男友服／／喜好：★★　　　<br>邪念：★★★　　",
"/i/cj/xp/112／黑色帽子／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/117／松糕鞋／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/116／色情服饰／／喜好：★　　　　<br>邪念：★★★　　",

"hr／属性",
"/i/cj/xp/59／少女／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/32／大姐姐／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/49／大姐姐×正太／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/106／女高中生／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/48／兄×妹／独生子女的执念／喜好：★★★　　<br>邪念：★　　　　",
"/i/cj/xp/37／姐×弟／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/100／宠物系女友／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/58／轻度福瑞／／喜好：★　　　　<br>邪念：★　　　　",

"hr／亲密接触",
"/i/cj/xp/114／牵手／／喜好：★★★★　<br>邪念：★★★　　",
"/i/cj/xp/121／拥抱／／喜好：★★★★　<br>邪念：★★★　　",
"/i/cj/xp/56／摸脸 ★／／喜好：★★★★★<br>邪念：★★★　　",
"/i/cj/xp/61／脸贴脸 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/57／摸头／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/90／间接接吻／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/78／轻吻／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/80／舌吻／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/5／倒吻／／喜好：★★　　　<br>邪念：★★★　　",
"/i/cj/xp/65／坐在怀里／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/122／在女生怀里被摸头／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/30／一起泡澡／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/70／给女生洗澡 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/76／女生给男生洗澡 ★／／喜好：★★★★　<br>邪念：★★★★　",

"hr／性爱",
"/i/cj/xp/69／从背后抱着手淫 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/39／口交 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/38／抠 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/44／舔 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/16／女上阴部摩擦／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/34／69式 ★★★／／喜好：★★★★★<br>邪念：★★★★★",

"hr／性别",
"/i/cj/xp/18／女性强势 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/103／可爱的男孩子／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/15／男娘／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/14／男娘×女／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/102／扶她 ★／／喜好：★★★　　<br>邪念：★★★★★",
"/i/cj/xp/28／伪男半裸／／喜好：★★★　　<br>邪念：★★★　　",

"hr／百合",
"/i/cj/xp/4／百合 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/94／直女×直女 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/66／Les Kiss ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/67／百合口交／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/74／磨豆腐／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/2／Les×Boy ★★／／喜好：★★★★　<br>邪念：★★★★★",

"hr／轻度露出",
"/i/cj/xp/109／凸点／／喜好：★★★★　<br>邪念：★★★　　",
"/i/cj/xp/33／走光／／喜好：★★★★　<br>邪念：★★　　　",
"/i/cj/xp/104／领口走光／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/45／提起裙子／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/50／真空／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/31／意外的裸露行为／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/97／CFNF ★／／喜好：★★★★　<br>邪念：★★★★　",

"hr／中度露出",
"/i/cj/xp/10／露出 ★★／／喜好：★★★★★<br>邪念：★★★★　",
"/i/cj/xp/24／生活感、无防备 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/113／换衣服／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/12／裸体模特／／喜好：★★★★　<br>邪念：★★★　　",
"/i/cj/xp/73／当裸体模特／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/27／脱衣游戏 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/51／桌下口交／／喜好：★★★★　<br>邪念：★★★　　",
"/i/cj/xp/26／偷偷自慰 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/25／偷偷性爱 ★★／／喜好：★★★★　<br>邪念：★★★★★",
"/i/cj/xp/22／看女生全裸外出／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/79／全裸外出 ★★／／喜好：★★★★★<br>邪念：★★★★　",
"/i/cj/xp/35／CFNM（男裸） ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/36／CMNF（女裸） ★★／／喜好：★★★★　<br>邪念：★★★★★",

"hr／重度露出",
"/i/cj/xp/75／女暴露癖／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/82／无人在意的全裸 ★★／／喜好：★★★★★<br>邪念：★★★★　",
"/i/cj/xp/21／强制露出／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/7／公开性爱／／喜好：★★★　　<br>邪念：★★★★　",

"hr／拍摄、观察",
"/i/cj/xp/13／裸体自拍／／喜好：★★★★　<br>邪念：★★★　　",
"/i/cj/xp/77／女生和丁丁合照／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/87／性爱自拍／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/43／全裸合照／／喜好：★★★★　<br>邪念：★★★　　",
"/i/cj/xp/47／性器观察 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/6／非色情的裸露 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/86／裸体摄影 ★／／喜好：★★★★　<br>邪念：★★★★　",

"hr／多人",
"/i/cj/xp/96／多人恋爱 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/29／一男多女 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/72／口交夹心 ★★／／喜好：★★★★　<br>邪念：★★★★★",
"/i/cj/xp/71／夹心插入 ★★／／喜好：★★★★　<br>邪念：★★★★★",

"hr／逆寝取",
"/i/cj/xp/19／女性助攻 ★★★／／喜好：★★★★★<br>邪念：★★★★★",
"/i/cj/xp/40／逆NTR ★★★／／喜好：★★★★★<br>邪念：★★★★★",

"hr／轻度SM",
"/i/cj/xp/8／口内指責／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/111／被舔脚／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/41／掐脖子／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/46／项圈／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/89／SP／／喜好：★★<br>邪念：★★",

"hr／纯洁的东西／我也不知道为什么对它们有邪念……",
"/i/cj/xp/52／被告白／／喜好：★★　　　<br>邪念：★★★　　",
"/i/cj/xp/53／分手／／喜好：★★　　　<br>邪念：★★★　　",
"/i/cj/xp/9／哭泣／／喜好：★★　　　<br>邪念：★★★　　",
"/i/cj/xp/63／无邪念的同床睡觉／一个神奇的悖论／喜好：★★★　　<br>邪念：★★★　　<br>“无邪念”这点会比普通“同床睡觉”更让我起邪念，但既然起邪念了这就不是“无邪念”的了……",
"/i/cj/xp/118／洗发水的香味／／喜好：★★　　　<br>邪念：★★　　　",

"hr／其他",
"/i/cj/xp/20／女性自慰 ★／／喜好：★★★★　<br>邪念：★★★★　",
"/i/cj/xp/64／性瘾／／喜好：★★★　　<br>邪念：★★★★　",
"/i/cj/xp/60／事后／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/62／无套／／喜好：★★★　　<br>邪念：★★★　　",
"/i/cj/xp/68／绷带散开／／喜好：★★　　　<br>邪念：★★★　　　",
"/i/cj/xp/85／动物尾肛塞／／喜好：★★　　　<br>邪念：★★　　　",
"/i/cj/xp/88／异物塞入／／喜好：★★　　　<br>邪念：★★★　　",
"/i/cj/xp/98／彩绘／／喜好：★★★　　<br>邪念：★★　　　",
"/i/cj/xp/99／彩绘代替衣服／／喜好：★★★　　<br>邪念：★★★★　",


],
"血腥、暴力、猎奇":[
"hr／暴力",
"/i/cj/xp/3／霸凌／／喜好：★★　　　<br>邪念：★★★　　<br>现实中不喜欢霸凌",
"/i/cj/xp/17／女性霸凌／／喜好：★★★　　<br>邪念：★★★　　",

"hr／血腥",
"/i/cj/xp/42／轻度割伤／／喜好：★<br>邪念：★★★　　<br>我不喜欢受伤和伤口，还有点晕血来着，但不知道为什么会对这个有反应……",

"hr／淫乱",
"/i/cj/xp/11／乱交、淫乱感／／喜好：★★★　　<br>邪念：★★★★　",

"hr／猎奇",
"/i/cj/xp/23／人棍／／喜好：★★　　　<br>邪念：★★　　　",

]
};

(function () {
    const processBlockOrder = [8,6,2,0,4,7,1,3,5];
    const restoreBlockOrder = new Array(9);
    processBlockOrder.forEach((sourceIdx, targetIdx) => {
        restoreBlockOrder[sourceIdx] = targetIdx;
    });

    const dyContainer = document.getElementById('dy');
    const processedImageUrls = new Map(); // 缓存：URL -> 处理后的base64，复用已处理结果
    const processingUrls = new Set(); // 防止同一URL并发处理
    const canvasPool = []; // canvas对象池，减少DOM创建销毁开销

    // 初始化已存在的图片（异步批量处理）
    const existingImgs = Array.from(dyContainer.querySelectorAll('img'));
    batchProcessImages(existingImgs);

    const observer = new MutationObserver((mutations) => {
        const newImgs = [];
        mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
                if (node.tagName === 'IMG') {
                    newImgs.push(node);
                } else {
                    newImgs.push(...node.querySelectorAll('img'));
                }
            });
        });
        // 批量处理新图片，避免频繁触发
        if (newImgs.length > 0) {
            batchProcessImages(newImgs);
        }
    });

    observer.observe(dyContainer, {
        childList: true,
        subtree: true
    });

    /**
     * 批量处理图片（异步非阻塞）
     * @param {HTMLImageElement[]} imgs 图片数组
     */
    function batchProcessImages(imgs) {
        // 去重 + 过滤已处理/处理中的图片
        const filteredImgs = imgs.filter(img => {
            return !img.dataset.restored && 
                   !processedImageUrls.has(img.src) && 
                   !processingUrls.has(img.src) &&
                   img.src && img.src.startsWith('http'); // 排除空/本地URL
        });

        // 异步并行处理（控制并发数，避免线程阻塞）
        const concurrency = 3; // 同时处理3张，可根据性能调整
        let index = 0;
        function processNext() {
            if (index >= filteredImgs.length) return;
            const img = filteredImgs[index++];
            handleImageLoad(img)
                .finally(() => {
                    setTimeout(processNext, 0); // 让出主线程
                });
        }
        // 启动并发处理
        for (let i = 0; i < concurrency; i++) {
            processNext();
        }
    }

    /**
     * 处理单张图片加载状态（异步函数）
     * @param {HTMLImageElement} img
     */
    async function handleImageLoad(img) {
        if (img.dataset.restored || processedImageUrls.has(img.src) || processingUrls.has(img.src)) {
            return;
        }
        processingUrls.add(img.src);

        try {
            // 等待图片加载完成（兼容异步）
            if (!img.complete || img.naturalWidth === 0) {
                await new Promise((resolve, reject) => {
                    const loadHandler = () => {
                        img.removeEventListener('load', loadHandler);
                        img.removeEventListener('error', errorHandler);
                        resolve();
                    };
                    const errorHandler = () => {
                        img.removeEventListener('load', loadHandler);
                        img.removeEventListener('error', errorHandler);
                        reject(new Error(`图片加载失败: ${img.src}`));
                    };
                    img.addEventListener('load', loadHandler, { once: true });
                    img.addEventListener('error', errorHandler, { once: true });
                });
            }

            // 优先使用缓存的处理结果
            if (processedImageUrls.has(img.src)) {
                img.src = processedImageUrls.get(img.src);
                img.dataset.restored = 'true';
                return;
            }

            // 异步还原图片（不阻塞主线程）
            const restoredBase64 = await restoreImage(img);
            if (restoredBase64) {
                img.src = restoredBase64;
                img.dataset.restored = 'true';
                processedImageUrls.set(img.src, restoredBase64); // 缓存结果
            }
        } catch (e) {
            console.warn(`处理图片失败: ${img.src}`, e);
        } finally {
            processingUrls.delete(img.src);
        }
    }

    /**
     * 还原图片（优化像素操作 + 复用canvas）
     * @param {HTMLImageElement} img
     * @returns {Promise<string>} 处理后的base64
     */
    function restoreImage(img) {
        return new Promise((resolve) => {
            // 从对象池获取canvas，减少创建开销
            let canvas = canvasPool.pop() || document.createElement('canvas');
            let ctx = canvas.getContext('2d');
            const tempImage = new Image();
            tempImage.crossOrigin = 'anonymous';

            tempImage.onload = function () {
                try {
                    const width = tempImage.width;
                    const height = tempImage.height;
                    canvas.width = width;
                    canvas.height = height;

                    // 一次性绘制原始图片（减少ctx操作）
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(tempImage, 0, 0);
                    let imageData = ctx.getImageData(0, 0, width, height);
                    const data = imageData.data;

                    // 优化：合并像素操作（一次遍历完成所有变换，减少循环次数）
                    imageData = optimizePixelTransform(imageData, width, height, restoreBlockOrder);

                    ctx.putImageData(imageData, 0, 0);
                    const base64 = canvas.toDataURL('image/jpeg', 0.9); // 降低压缩质量提速（可调整）
                    
                    // 重置canvas并放回对象池
                    canvas.width = 0;
                    canvas.height = 0;
                    canvasPool.push(canvas);
                    
                    resolve(base64);
                } catch (e) {
                    console.error(`还原图片失败: ${img.src}`, e);
                    canvasPool.push(canvas); // 回收canvas
                    resolve(null);
                }
            };

            tempImage.onerror = function () {
                console.warn(`临时图片加载失败: ${img.src}`);
                canvasPool.push(canvas); // 回收canvas
                resolve(null);
            };

            tempImage.src = img.src;
        });
    }

    /**
     * 优化：合并所有像素变换（分块、翻转、反色），一次遍历完成
     * 原逻辑：3次独立遍历像素，现在1次遍历完成，减少2/3的循环耗时
     * @param {ImageData} imageData
     * @param {number} width
     * @param {number} height
     * @param {array} order
     * @returns {ImageData}
     */
    function optimizePixelTransform(imageData, width, height, order) {
        const blockWidth = Math.floor(width / 3);
        const blockHeight = Math.floor(height / 3);
        const newData = new Uint8ClampedArray(imageData.data.length);
        const data = imageData.data;

        // 预计算所有块的位置（减少重复计算）
        const blockPositions = [];
        for (let i = 0; i < 9; i++) {
            blockPositions[i] = getBlockPosition(i, blockWidth, blockHeight);
        }

        // 一次遍历完成：分块还原 + 上下翻转 + 反色
        for (let targetIdx = 0; targetIdx < 9; targetIdx++) {
            const sourceIdx = order[targetIdx];
            const [sourceX, sourceY] = blockPositions[sourceIdx];
            const [targetX, targetY] = blockPositions[targetIdx];

            for (let y = 0; y < blockHeight; y++) {
                for (let x = 0; x < blockWidth; x++) {
                    // 1. 计算原分块位置的像素索引
                    const sourceYFlip = height - 1 - (sourceY + y); // 提前计算翻转后的Y坐标
                    const sourcePixelIndex = (sourceYFlip * width + (sourceX + x)) * 4;
                    
                    // 2. 计算目标位置索引
                    const targetPixelIndex = ((targetY + y) * width + (targetX + x)) * 4;

                    if (sourcePixelIndex < data.length && targetPixelIndex < newData.length) {
                        // 3. 反色 + 赋值（一次完成）
                        newData[targetPixelIndex] = 255 - data[sourcePixelIndex];     // R
                        newData[targetPixelIndex + 1] = 255 - data[sourcePixelIndex + 1]; // G
                        newData[targetPixelIndex + 2] = 255 - data[sourcePixelIndex + 2]; // B
                        newData[targetPixelIndex + 3] = data[sourcePixelIndex + 3];       // A（不变）
                    }
                }
            }
        }

        return new ImageData(newData, width, height);
    }

    // 原有函数（仅保留位置计算）
    function getBlockPosition(index, blockWidth, blockHeight) {
        const row = Math.floor(index / 3);
        const col = index % 3;
        return [col * blockWidth, row * blockHeight];
    }

    // 页面卸载时清理缓存，避免内存泄漏
    window.addEventListener('unload', () => {
        processedImageUrls.clear();
        processingUrls.clear();
        canvasPool.length = 0;
        observer.disconnect();
    });
})();
</script>
<div id="yzdy"></div>
<script src="https://猫.cafe/biji/0/mq-手动确认.js"></script>