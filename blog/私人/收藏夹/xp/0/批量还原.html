<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>批量图片还原工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .upload-area {
            margin-bottom: 20px;
        }
        .btn-group {
            margin: 20px 0;
        }
        button {
            padding: 8px 16px;
            margin-right: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            font-size: 14px;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #image-container {
            width: 100%;
            min-height: 300px;
            border: 1px dashed #ccc;
            display: flex;
            flex-wrap: wrap;
            align-items: flex-start;
            justify-content: flex-start;
            overflow: auto;
            padding: 10px;
            gap: 10px;
        }
        .image-item {
            width: 200px;
            height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #eee;
            border-radius: 4px;
            overflow: hidden;
        }
        .image-item img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
    </style>
    <!-- 引入jszip和file-saver库，用于打包下载 -->
    <script src="jszip.min.js"></script>
    <script src="FileSaver.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="upload-area">
            <!-- 支持多选已处理的图片文件 -->
            <input type="file" id="file-upload" accept="image/*" multiple>
        </div>
        <div class="btn-group">
            <button id="download-all-btn" disabled>全部下载</button>
            <button id="clear-btn">清空列表</button>
        </div>
        <div id="image-container">
            <!-- 批量还原后的图片预览将动态生成 -->
        </div>
    </div>

    <script>
        // 全局变量
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        const fileUpload = document.getElementById('file-upload');
        const downloadAllBtn = document.getElementById('download-all-btn');
        const clearBtn = document.getElementById('clear-btn');
        const imageContainer = document.getElementById('image-container');
        // 存储所有还原后的图片数据：{ name: 文件名, blob: 图片Blob数据, url: 预览URL }
        let restoredImages = [];

        // 原处理逻辑的3x3分块换位顺序（索引从0开始，0-8对应9个块）
        const processBlockOrder = [8,6,2,0,4,7,1,3,5];
        // 还原用的反向分块顺序（根据原顺序推导）
        const restoreBlockOrder = getReverseOrder(processBlockOrder);

        // 1. 监听文件上传（支持批量）
        fileUpload.addEventListener('change', async function (e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;

            // 遍历所有上传的已处理图片
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (!file.type.startsWith('image/')) continue;

                try {
                    // 还原单张已处理的图片
                    await restoreSingleImage(file);
                } catch (error) {
                    console.error(`还原图片${file.name}失败：`, error);
                    alert(`还原图片${file.name}失败，请检查图片格式！`);
                }
            }

            // 启用全部下载按钮
            if (restoredImages.length > 0) {
                downloadAllBtn.disabled = false;
            }

            // 清空文件选择框，允许重复上传相同文件
            fileUpload.value = '';
        });

        // 2. 全部下载按钮点击事件
        downloadAllBtn.addEventListener('click', async function () {
            if (restoredImages.length === 0) return;

            // 创建ZIP对象
            const zip = new JSZip();
            // 遍历还原后的图片，添加到ZIP中
            restoredImages.forEach((img) => {
                const fileName = `${img.name}`;
                zip.file(fileName, img.blob);
            });

            // 生成ZIP文件并下载
            try {
                const zipContent = await zip.generateAsync({ type: 'blob' });
                saveAs(zipContent, 'restored-images.zip'); // 使用file-saver库下载
            } catch (error) {
                console.error('打包图片失败：', error);
                alert('打包图片失败，请重试！');
            }
        });

        // 3. 清空列表按钮点击事件
        clearBtn.addEventListener('click', function () {
            restoredImages = [];
            imageContainer.innerHTML = '';
            downloadAllBtn.disabled = true;
        });

        // ---------------------- 核心还原函数 ----------------------
        /**
         * 还原单张已处理的图片
         * @param {File} file - 上传的已处理图片文件
         * @returns {Promise}
         */
        function restoreSingleImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const processedImage = new Image();
                    // 解决跨域问题
                    processedImage.crossOrigin = 'anonymous';
                    processedImage.onload = function () {
                        try {
                            // 初始化Canvas尺寸
                            canvas.width = processedImage.width;
                            canvas.height = processedImage.height;

                            // 步骤1：绘制已处理图片到Canvas（添加白色背景）
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(processedImage, 0, 0);
                            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                            // 步骤1：反向3x3分块换位（还原分块）
                            imageData = rearrangeBlocks(imageData, canvas.width, canvas.height, restoreBlockOrder);

                            // 步骤2：反向上下翻转（再次上下翻转即可还原）
                            imageData = flipVertical(imageData, canvas.width, canvas.height);

                            // 步骤3：反向反色（再次反色即可还原）
                            imageData = invertColor(imageData);

                            // 将还原后的图片数据绘制到Canvas
                            ctx.putImageData(imageData, 0, 0);

                            // 将Canvas内容转换为Blob和预览URL
                            canvas.toBlob((blob) => {
                                const imageUrl = URL.createObjectURL(blob);
                                // 存储还原后的图片数据
                                restoredImages.push({
                                    name: file.name,
                                    blob: blob,
                                    url: imageUrl
                                });

                                // 生成预览元素并添加到容器
                                createImagePreview(imageUrl, file.name);

                                resolve();
                            }, 'image/jpeg', 1.0);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    processedImage.src = event.target.result;
                    // 处理图片加载失败的情况
                    processedImage.onerror = reject;
                };
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        /**
         * 创建图片预览元素
         * @param {string} imageUrl - 图片预览URL
         * @param {string} fileName - 图片文件名
         */
        function createImagePreview(imageUrl, fileName) {
            const imageItem = document.createElement('div');
            imageItem.className = 'image-item';
            imageItem.title = fileName;

            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = fileName;

            imageItem.appendChild(img);
            imageContainer.appendChild(imageItem);
        }

        /**
         * 反色处理（再次调用即可还原）
         * @param {ImageData} imageData - 图片像素数据
         * @returns {ImageData} 处理后的图片数据
         */
        function invertColor(imageData) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 255 - data[i]; // 红通道
                data[i + 1] = 255 - data[i + 1]; // 绿通道
                data[i + 2] = 255 - data[i + 2]; // 蓝通道
            }
            return imageData;
        }

        /**
         * 上下翻转（再次调用即可还原）
         * @param {ImageData} imageData - 图片像素数据
         * @param {number} width - 图片宽度
         * @param {number} height - 图片高度
         * @returns {ImageData} 翻转后的图片数据
         */
        function flipVertical(imageData, width, height) {
            const newData = new Uint8ClampedArray(imageData.data.length);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const originalIndex = (y * width + x) * 4;
                    const newIndex = ((height - 1 - y) * width + x) * 4;
                    newData[newIndex] = data[originalIndex];
                    newData[newIndex + 1] = data[originalIndex + 1];
                    newData[newIndex + 2] = data[originalIndex + 2];
                    newData[newIndex + 3] = data[originalIndex + 3];
                }
            }
            return new ImageData(newData, width, height);
        }

        /**
         * 3x3分块换位（用于还原）
         * @param {ImageData} imageData - 图片像素数据
         * @param {number} width - 图片宽度
         * @param {number} height - 图片高度
         * @param {array} order - 还原用的分块顺序
         * @returns {ImageData} 换位后的图片数据
         */
        function rearrangeBlocks(imageData, width, height, order) {
            const blockWidth = Math.floor(width / 3);
            const blockHeight = Math.floor(height / 3);
            const newData = new Uint8ClampedArray(imageData.data.length);
            const data = imageData.data;

            for (let targetIdx = 0; targetIdx < 9; targetIdx++) {
                const sourceIdx = order[targetIdx];
                const [sourceX, sourceY] = getBlockPosition(sourceIdx, blockWidth, blockHeight);
                const [targetX, targetY] = getBlockPosition(targetIdx, blockWidth, blockHeight);

                for (let y = 0; y < blockHeight; y++) {
                    for (let x = 0; x < blockWidth; x++) {
                        const sourcePixelIndex = ((sourceY + y) * width + (sourceX + x)) * 4;
                        const targetPixelIndex = ((targetY + y) * width + (targetX + x)) * 4;

                        if (sourcePixelIndex < data.length && targetPixelIndex < newData.length) {
                            newData[targetPixelIndex] = data[sourcePixelIndex];
                            newData[targetPixelIndex + 1] = data[sourcePixelIndex + 1];
                            newData[targetPixelIndex + 2] = data[sourcePixelIndex + 2];
                            newData[targetPixelIndex + 3] = data[sourcePixelIndex + 3];
                        }
                    }
                }
            }

            return new ImageData(newData, width, height);
        }

        /**
         * 根据块索引获取起始坐标
         * @param {number} index - 块索引（0-8）
         * @param {number} blockWidth - 块宽度
         * @param {number} blockHeight - 块高度
         * @returns {array} [x, y]
         */
        function getBlockPosition(index, blockWidth, blockHeight) {
            const row = Math.floor(index / 3);
            const col = index % 3;
            return [col * blockWidth, row * blockHeight];
        }

        /**
         * 根据原处理顺序推导反向还原顺序
         * @param {array} originalOrder - 原处理用的分块顺序
         * @returns {array} 还原用的反向顺序
         */
        function getReverseOrder(originalOrder) {
            const reverseOrder = new Array(9);
            for (let i = 0; i < originalOrder.length; i++) {
                reverseOrder[originalOrder[i]] = i;
            }
            return reverseOrder;
        }
    </script>
</body>
</html>