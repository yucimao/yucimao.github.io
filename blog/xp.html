---
layout: chengjiu
title: XP
nav_url: <a href="/maoqiu">关于</a>
permalink: xp
---
<script>
// "hr／标题",
// "111／标题／小字／提示",
// ／u／https://xx",
// ／o／dw(dwb='111',dwd='标题')",
let cj_data={
"普通XP":[

"653366.st／测试／／",
"16555523.png／测试／／",
// "0／贫乳／／",
// "0／萝莉／／",
// "0／御姐／／",

],
"R18":[
    
]
};

    // ========== 新增：全局种子变量（可根据需要修改初始值） ==========
    let globalSeed = 12345; // 这个变量作为统一的种子，可在外部修改

    // 获取DOM元素（原有部分，保留）
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    const obfuscateBtn = document.getElementById('obfuscate-btn');
    const restoreBtn = document.getElementById('restore-btn');
    const saveBtn = document.getElementById('save-btn');
    const seedInput = document.getElementById('seed-input');
    const originalCanvas = document.getElementById('original-canvas');
    const resultCanvas = document.getElementById('result-canvas');
    const originalStatus = document.getElementById('original-status');
    const resultStatus = document.getElementById('result-status');
    // ========== 新增：获取dy容器 ==========
    const dyContainer = document.getElementById('dy');
    
    // 获取Canvas上下文（原有部分，保留）
    const originalCtx = originalCanvas.getContext('2d');
    const resultCtx = resultCanvas.getContext('2d');
    
    // 存储原始图像数据（原有部分，保留）
    let originalImageData = null;
    
    // 上传区域点击事件（原有部分，保留）
    uploadArea?.addEventListener('click', () => {
        fileInput.click();
    });
    
    // 拖放功能实现（原有部分，保留）
    uploadArea?.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.style.borderColor = '#4CAF50';
        uploadArea.style.backgroundColor = '#f0fff0';
    });
    
    uploadArea?.addEventListener('dragleave', () => {
        uploadArea.style.borderColor = '#ccc';
        uploadArea.style.backgroundColor = 'transparent';
    });
    
    uploadArea?.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.style.borderColor = '#ccc';
        uploadArea.style.backgroundColor = 'transparent';
        
        if (e.dataTransfer.files.length) {
            handleImageUpload(e.dataTransfer.files[0]);
        }
    });
    
    // 文件选择事件（原有部分，保留）
    fileInput?.addEventListener('change', (e) => {
        if (e.target.files.length) {
            handleImageUpload(e.target.files[0]);
        }
    });
    
    // 按钮点击事件（原有部分，保留，修改种子为全局种子）
    obfuscateBtn?.addEventListener('click', () => {
        if (originalImageData) {
            // 同步输入框的种子到全局种子（可选，也可直接用全局种子）
            globalSeed = parseInt(seedInput.value) || globalSeed;
            processImage('obfuscate');
        }
    });
    
    restoreBtn?.addEventListener('click', () => {
        if (originalImageData) {
            globalSeed = parseInt(seedInput.value) || globalSeed;
            processImage('restore');
        }
    });
    
    saveBtn?.addEventListener('click', saveProcessedImage);
    
    // 处理图片上传（原有部分，保留）
    function handleImageUpload(file) {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            const img = new Image();
            // 解决跨域问题（如果图片是外部链接需要添加）
            img.crossOrigin = 'anonymous';
            
            img.onload = () => {
                // 设置Canvas尺寸
                originalCanvas.width = img.width;
                originalCanvas.height = img.height;
                resultCanvas.width = img.width;
                resultCanvas.height = img.height;
                
                // 绘制原始图像
                originalCtx.drawImage(img, 0, 0);
                originalImageData = originalCtx.getImageData(0, 0, img.width, img.height);
                
                // 清空结果画布
                resultCtx.clearRect(0, 0, img.width, img.height);
                
                // 更新状态和按钮
                originalStatus.textContent = `已上传 (${img.width} × ${img.height})`;
                resultStatus.textContent = '等待处理';
                obfuscateBtn.disabled = false;
                restoreBtn.disabled = false;
                saveBtn.disabled = true;
            };
            
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
    }
    
    // 伪随机数生成器 - 确保相同种子产生相同序列（原有部分，保留）
    class PRNG {
        constructor(seed) {
            // 使用线性同余生成器(LCG)算法
            this.seed = seed % 2147483647;
            if (this.seed <= 0) this.seed += 2147483646;
        }
        
        // 生成下一个随机数
        next() {
            return this.seed = this.seed * 16807 % 2147483647;
        }
        
        // 生成0到max-1之间的随机整数
        randomInt(max) {
            return this.next() % max;
        }
    }
    
    // 处理图片（混淆或还原）（原有部分，修改种子为全局种子）
    function processImage(action) {
        const seed = globalSeed; // 使用全局种子
        const prng = new PRNG(seed);
        
        // 获取源图像数据（混淆时使用原图，还原时使用结果图）
        const sourceCanvas = action === 'obfuscate' ? originalCanvas : resultCanvas;
        const sourceCtx = sourceCanvas.getContext('2d'); // 修复原有动态获取的问题，直接获取上下文
        const sourceImageData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
        const sourceData = new Uint8ClampedArray(sourceImageData.data);
        
        const width = sourceImageData.width;
        const height = sourceImageData.height;
        const pixelCount = width * height;
        
        // 生成像素交换映射表
        const swapMap = createSwapMap(pixelCount, prng);
        
        // 创建处理后的像素数据
        const processedData = new Uint8ClampedArray(pixelCount * 4);
        
        for (let i = 0; i < pixelCount; i++) {
            // 混淆时使用映射表，还原时使用反向映射
            const sourceIndex = action === 'obfuscate' ? swapMap[i] : i;
            const targetIndex = action === 'obfuscate' ? i : swapMap[i];
            
            // 复制像素的RGBA值
            processedData[targetIndex * 4] = sourceData[sourceIndex * 4];         // R
            processedData[targetIndex * 4 + 1] = sourceData[sourceIndex * 4 + 1]; // G
            processedData[targetIndex * 4 + 2] = sourceData[sourceIndex * 4 + 2]; // B
            processedData[targetIndex * 4 + 3] = sourceData[sourceIndex * 4 + 3]; // A
        }
        
        // 创建ImageData对象并绘制到结果画布
        const imageData = new ImageData(processedData, width, height);
        resultCtx.putImageData(imageData, 0, 0);
        
        // 更新状态
        const actionText = action === 'obfuscate' ? '混淆' : '还原';
        resultStatus.textContent = `已${actionText} (种子: ${seed})`;
        saveBtn.disabled = false;
    }
    
    // 创建像素交换映射表（原有部分，保留）
    function createSwapMap(pixelCount, prng) {
        // 初始化映射表
        const swapMap = new Array(pixelCount);
        for (let i = 0; i < pixelCount; i++) {
            swapMap[i] = i;
        }
        
        // 使用Fisher-Yates洗牌算法生成随机映射
        for (let i = pixelCount - 1; i > 0; i--) {
            const j = prng.randomInt(i + 1);
            // 交换元素
            [swapMap[i], swapMap[j]] = [swapMap[j], swapMap[i]];
        }
        
        return swapMap;
    }
    
    // 保存处理后的图片（原有部分，保留）
    function saveProcessedImage() {
        try {
            // 创建下载链接
            const link = document.createElement('a');
            link.download = 'processed-image.png';
            link.href = resultCanvas.toDataURL('image/png');
            link.click();
            
            // 显示保存成功信息
            console.log("图片保存成功")
        } catch (error) {
            console.log("失败"+error.message)
        }
    }

    // ========== 新增：核心功能 - 还原动态加载的混淆图片 ==========
    /**
     * 还原混淆的图片
     * @param {HTMLImageElement} img - 需要还原的混淆图片元素
     * @returns {Promise<string>} 还原后的图片base64地址
     */
    async function restoreObfuscatedImage(img) {
        return new Promise((resolve) => {
            // 创建临时canvas用于处理图片
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // 等图片加载完成后处理
            const imgObj = new Image();
            imgObj.crossOrigin = 'anonymous'; // 解决跨域问题
            imgObj.onload = function() {
                // 设置canvas尺寸和图片一致
                tempCanvas.width = imgObj.width;
                tempCanvas.height = imgObj.height;
                // 绘制混淆的图片到canvas
                tempCtx.drawImage(imgObj, 0, 0);
                // 获取混淆图片的像素数据
                const obfuscatedImageData = tempCtx.getImageData(0, 0, imgObj.width, imgObj.height);
                const obfuscatedData = new Uint8ClampedArray(obfuscatedImageData.data);
                
                const width = obfuscatedImageData.width;
                const height = obfuscatedImageData.height;
                const pixelCount = width * height;
                
                // 使用全局种子创建PRNG和交换映射表
                const prng = new PRNG(globalSeed);
                const swapMap = createSwapMap(pixelCount, prng);
                
                // 还原像素数据（和原有还原逻辑一致）
                const restoredData = new Uint8ClampedArray(pixelCount * 4);
                for (let i = 0; i < pixelCount; i++) {
                    const sourceIndex = i;
                    const targetIndex = swapMap[i];
                    restoredData[targetIndex * 4] = obfuscatedData[sourceIndex * 4];
                    restoredData[targetIndex * 4 + 1] = obfuscatedData[sourceIndex * 4 + 1];
                    restoredData[targetIndex * 4 + 2] = obfuscatedData[sourceIndex * 4 + 2];
                    restoredData[targetIndex * 4 + 3] = obfuscatedData[sourceIndex * 4 + 3];
                }
                
                // 绘制还原后的像素数据到canvas
                const restoredImageData = new ImageData(restoredData, width, height);
                tempCtx.putImageData(restoredImageData, 0, 0);
                
                // 获取还原后的base64地址
                const restoredSrc = tempCanvas.toDataURL('image/png');
                resolve(restoredSrc);
            };
            imgObj.src = img.src;
        });
    }

    /**
     * 监控dy容器中新增的图片并还原
     */
    function monitorDyContainer() {
        if (!dyContainer) {
            console.warn('未找到id为dy的容器');
            return;
        }

        // 创建MutationObserver实例，监控子节点变化
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                // 遍历新增的节点
                mutation.addedNodes.forEach((node) => {
                    // 情况1：新增的节点本身是img元素
                    if (node.tagName === 'IMG') {
                        handleNewImage(node);
                    }
                    // 情况2：新增的节点是容器，里面包含img元素
                    else if (node.querySelectorAll) {
                        node.querySelectorAll('img').forEach((img) => {
                            handleNewImage(img);
                        });
                    }
                });
            });
        });

        // 配置监控选项：监控子节点的添加、以及子节点的子节点变化
        observer.observe(dyContainer, {
            childList: true,
            subtree: true,
            attributes: false,
            characterData: false
        });

        // 处理新增的图片元素
        async function handleNewImage(img) {
            // 防止重复处理（添加标记）
            if (img.dataset.restored) {
                return;
            }
            img.dataset.restored = 'processing'; // 标记为正在处理

            try {
                // 还原图片
                const restoredSrc = await restoreObfuscatedImage(img);
                // 替换图片src为还原后的地址
                img.src = restoredSrc;
                img.dataset.restored = 'done'; // 标记为处理完成
            } catch (error) {
                console.error('图片还原失败：', error);
                img.dataset.restored = 'failed'; // 标记为处理失败
            }
        }

        // 初始处理dy容器中已有的图片（可选，根据需求决定）
        dyContainer.querySelectorAll('img').forEach((img) => {
            handleNewImage(img);
        });
    }

    // ========== 启动监控 ==========
    // 页面加载完成后启动监控
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', monitorDyContainer);
    } else {
        monitorDyContainer();
    }
</script>
<div id="yzdy"></div>
<script src="https://猫.cafe/biji/0/mq-手动确认.js"></script>